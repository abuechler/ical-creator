name: Auto-merge approved PRs

on:
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]
  pull_request:
    types: [ready_for_review]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Check if PR is approved and can be merged
        id: check
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const pr = context.payload.pull_request ||
                       (await github.rest.pulls.get({
                         owner: context.repo.owner,
                         repo: context.repo.repo,
                         pull_number: context.payload.number || context.payload.check_suite.pull_requests[0].number
                       })).data;

            if (!pr) {
              console.log('No PR found, skipping');
              return;
            }

            console.log(`Checking PR #${pr.number}: ${pr.title}`);

            // Check if PR is mergeable (no conflicts)
            if (pr.mergeable === false) {
              console.log('PR has conflicts, cannot auto-merge');
              return;
            }

            // Get reviews
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            // Check if there's at least one approval
            const approvals = reviews.data.filter(review => review.state === 'APPROVED');
            const rejections = reviews.data.filter(review => review.state === 'CHANGES_REQUESTED');

            if (rejections.length > 0) {
              console.log('PR has requested changes, cannot auto-merge');
              return;
            }

            if (approvals.length === 0) {
              console.log('PR not yet approved, cannot auto-merge');
              return;
            }

            console.log(`PR has ${approvals.length} approval(s)`);

            // Check if all status checks have passed
            const checks = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });

            const failedChecks = checks.data.check_runs.filter(
              check => check.conclusion !== 'success' && check.conclusion !== 'skipped' && check.status === 'completed'
            );

            if (failedChecks.length > 0) {
              console.log(`Some checks failed: ${failedChecks.map(c => c.name).join(', ')}`);
              return;
            }

            // Get commit statuses
            const statuses = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });

            // Wait for checks to complete (poll up to 10 minutes)
            const maxWaitMinutes = 10;
            const pollIntervalSeconds = 30;
            const maxAttempts = (maxWaitMinutes * 60) / pollIntervalSeconds;

            let attempt = 0;
            let allChecksPassed = false;

            while (attempt < maxAttempts) {
              // Re-check both check runs and statuses
              const currentChecks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });

              const currentStatuses = await github.rest.repos.getCombinedStatusForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });

              const stillPending = currentChecks.data.check_runs.some(check => check.status !== 'completed');
              const statusPending = currentStatuses.data.state === 'pending';

              if (!stillPending && !statusPending) {
                // Check if any failed
                const anyFailed = currentChecks.data.check_runs.some(
                  check => check.conclusion !== 'success' && check.conclusion !== 'skipped'
                );

                if (anyFailed || currentStatuses.data.state === 'failure') {
                  console.log('Some checks failed, cannot auto-merge');
                  return;
                }

                allChecksPassed = true;
                break;
              }

              attempt++;
              if (attempt < maxAttempts) {
                console.log(`Checks still pending, waiting ${pollIntervalSeconds}s... (attempt ${attempt}/${maxAttempts})`);
                await new Promise(resolve => setTimeout(resolve, pollIntervalSeconds * 1000));
              }
            }

            if (!allChecksPassed) {
              console.log('Checks did not complete within timeout, giving up');
              return;
            }

            // All conditions met, merge the PR
            console.log('All conditions met, merging PR...');

            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                merge_method: 'squash',
                commit_title: pr.title,
                commit_message: `${pr.body || ''}\n\nAuto-merged after approval`
              });

              console.log('PR merged successfully!');

              // Add a comment to notify
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: 'âœ… Auto-merged after approval and all checks passed.'
              });
            } catch (error) {
              console.log(`Failed to merge: ${error.message}`);
            }
