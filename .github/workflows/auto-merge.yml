name: Auto-merge approved PRs

on:
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]
  pull_request:
    types: [ready_for_review]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest

    steps:
      - name: Check and merge all approved PRs
        id: check
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            // Get all open PRs
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            if (pullRequests.length === 0) {
              console.log('No open PRs found');
              return;
            }

            console.log(`Found ${pullRequests.length} open PR(s), checking each one...`);

            // Check each PR
            for (const pr of pullRequests) {
              console.log(`\n========================================`);
              console.log(`Checking PR #${pr.number}: ${pr.title}`);

              // Skip draft PRs
              if (pr.draft) {
                console.log('PR is a draft, skipping');
                continue;
              }

              // Check if PR is mergeable (no conflicts)
              // Re-fetch PR to get latest mergeable status
              const { data: prDetails } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              if (prDetails.mergeable === false) {
                console.log('PR has conflicts, cannot auto-merge');
                continue;
              }

              // Get reviews
              const reviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              // Check if there's at least one approval
              const approvals = reviews.data.filter(review => review.state === 'APPROVED');
              const rejections = reviews.data.filter(review => review.state === 'CHANGES_REQUESTED');

              if (rejections.length > 0) {
                console.log('PR has requested changes, cannot auto-merge');
                continue;
              }

              if (approvals.length === 0) {
                console.log('PR not yet approved, cannot auto-merge');
                continue;
              }

              console.log(`PR has ${approvals.length} approval(s)`);

              // Check if all status checks have passed (excluding auto-merge itself)
              const checks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });

              // Filter out the auto-merge check itself to avoid circular dependency
              const relevantChecks = checks.data.check_runs.filter(
                check => check.name !== 'auto-merge'
              );

              const failedChecks = relevantChecks.filter(
                check => check.conclusion !== 'success' && check.conclusion !== 'skipped' && check.status === 'completed'
              );

              if (failedChecks.length > 0) {
                console.log(`Some checks failed: ${failedChecks.map(c => c.name).join(', ')}`);
                continue;
              }

              // Check if there are still pending checks (excluding auto-merge)
              const pendingChecks = relevantChecks.filter(
                check => check.status !== 'completed'
              );

              if (pendingChecks.length > 0) {
                console.log(`Some checks are still pending: ${pendingChecks.map(c => c.name).join(', ')}`);
                continue;
              }

              // Get commit statuses
              const statuses = await github.rest.repos.getCombinedStatusForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });

              // If there are no commit statuses at all, treat as success
              // (GitHub returns 'pending' state by default when total_count is 0)
              if (statuses.data.total_count > 0) {
                if (statuses.data.state === 'pending') {
                  console.log('Some commit statuses are still pending');
                  continue;
                }

                if (statuses.data.state === 'failure') {
                  console.log('Some commit statuses failed');
                  continue;
                }
              } else {
                console.log('No commit statuses found, proceeding');
              }

              // All conditions met, merge the PR
              console.log('All conditions met, merging PR...');

              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  merge_method: 'squash',
                  commit_title: pr.title,
                  commit_message: `${pr.body || ''}\n\nAuto-merged after approval`
                });

                console.log('✅ PR merged successfully!');

                // Add a comment to notify
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: '✅ Auto-merged after approval and all checks passed.'
                });
              } catch (error) {
                console.log(`Failed to merge: ${error.message}`);
              }
            }

            console.log(`\n========================================`);
            console.log('Finished checking all open PRs');
